#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <ArduinoOTA.h>
#include <EEPROM.h>
#include <ESP8266WebServer.h>
#include <ESP8266HTTPUpdateServer.h>

uint8_t newMACAddress[] = {0xCC, 0x50, 0xE3, 0x2E, 0x89, 0x05};


bool button;                        //контакт счетчика импульсов
bool display_number = false;        //номер страницы для вывода на экран (false - 1; true -2)
unsigned long count = 0;            //счетчик импульсов за счетное время (set_sime_seconds)
unsigned long temp = 0;             //
unsigned long premillis = 0;
unsigned long premillis_disp = 0;
unsigned long set_time_expo = 0;    //время экспозиции в милисекундах
byte set_time_change_display = 5;   //время смены информации на дисплее в секундах
unsigned long time_on;              //время работы
float dose = 0;                     //доза за время работы

byte hh = 0;                        //время работы часы минуты секунды
byte mm = 0;
byte ss = 0;

struct ESP_Config {                         //структура для хранения настроек в EEPROM памяти. Переменные структуры записаны большими буквами, для их отличия от других глобальных переменных
  char    MUSOR[16] = {};                   //В начале сектора EEPROM содержатся какие-то данные ESP, запись туда важных данных нежелательна
  // Наименование в режиме клиента
  char    WIFI_SSID[32] = {};               //имя сети
  char    WIFI_PASSWORD[32] = {};
  // Параметры подключения в режиме точки доступа
  char    AP_SSID[32] = {};                 //имя точки доступа
  char    AP_PASSWORD[32] = {};
  // Время экспозиции и отправка данных
  uint16_t EXPOSITION = 5;
  bool    SEND_NM = false;                  //разрешение на отправку данных Narodmon.ru
} Config;


Adafruit_SSD1306 display(-1);
//ESP8266 SDA pin = D2; SCK pin = D1
// I2C pins                                 //Wemos ESP8266
#define SDA_pin 4                           //D2 pin
#define SCL_pin 5                           //D1 pin

ESP8266HTTPUpdateServer httpUpdater;
ESP8266WebServer server(80);
WiFiClient client;                          // для отправки данных на narodmon.ru
static const unsigned char PROGMEM logo[] =
{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xff, 0xff, 0xfd, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xfc, 0x1f, 0xff, 0xff, 0xfd, 0xff, 0xff, 0xff, 0xfd, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xfd, 0xef, 0xff, 0xff, 0xfd, 0xff, 0xff, 0xff, 0xfd, 0xfb, 0xff, 0xff, 0xff, 0xc0, 0x0f, 0xff,
  0xfd, 0xf7, 0x0e, 0xee, 0x1d, 0xc3, 0xa3, 0xc3, 0xc1, 0xfa, 0x3b, 0xbf, 0xff, 0x80, 0x07, 0xff,
  0xfd, 0xf6, 0xf6, 0xed, 0xed, 0xbd, 0x9d, 0xbd, 0xbd, 0xf9, 0xdb, 0xbf, 0xff, 0xc0, 0x0f, 0xff,
  0xfd, 0xf6, 0xf7, 0x5d, 0xed, 0xbd, 0xbd, 0xbd, 0xbd, 0xfb, 0xdd, 0x7f, 0xff, 0xe0, 0x0f, 0xff,
  0xfd, 0xf6, 0x07, 0x5c, 0x0d, 0xbd, 0xbd, 0x81, 0xbd, 0xfb, 0xdd, 0x7f, 0xff, 0xe0, 0x1f, 0xff,
  0xfd, 0xf6, 0xff, 0x5d, 0xfd, 0xbd, 0xbd, 0xbf, 0xbd, 0xfb, 0xdd, 0x7f, 0xff, 0xf0, 0x1f, 0xff,
  0xfd, 0xee, 0xf7, 0xbd, 0xed, 0xbd, 0xbd, 0xbd, 0xb9, 0xfb, 0xde, 0xff, 0xff, 0xf0, 0x3f, 0xff,
  0xfc, 0x1f, 0x0f, 0xbe, 0x1d, 0xc3, 0x83, 0xc3, 0xc5, 0xf8, 0x3e, 0xff, 0xff, 0xf8, 0x7f, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xf8, 0x7f, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xff, 0xfc, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x7f, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xef, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x7f, 0xff,
  0xff, 0xf8, 0x7f, 0xff, 0xff, 0xff, 0xb0, 0x3f, 0xfb, 0xff, 0xff, 0xff, 0x80, 0x0c, 0xc0, 0x07,
  0xff, 0xf7, 0xbf, 0xff, 0xff, 0xff, 0xb7, 0xff, 0xfb, 0xff, 0xff, 0xff, 0xc0, 0x0f, 0xc0, 0x0f,
  0xff, 0xf7, 0xf7, 0x77, 0x0e, 0x98, 0x37, 0xee, 0x1a, 0x3f, 0xff, 0xff, 0xc0, 0x0f, 0xc0, 0x0f,
  0xff, 0xf7, 0xf7, 0x76, 0xf6, 0x77, 0xb7, 0xed, 0xf9, 0xdf, 0xff, 0xff, 0xc0, 0x1f, 0xe0, 0x0f,
  0xff, 0xf8, 0x7a, 0xae, 0xf6, 0xf7, 0xb0, 0x6d, 0xfb, 0xdf, 0xff, 0xff, 0xe0, 0x1f, 0xe0, 0x1f,
  0xff, 0xff, 0xba, 0xae, 0xf6, 0xf7, 0xb7, 0xee, 0x3b, 0xdf, 0xff, 0xff, 0xe0, 0x1f, 0xf0, 0x1f,
  0xff, 0xff, 0xba, 0xae, 0xf6, 0xf7, 0xb7, 0xef, 0xdb, 0xdf, 0xff, 0xff, 0xf0, 0x3f, 0xf0, 0x3f,
  0xff, 0xf7, 0xbd, 0xde, 0xf6, 0xf7, 0x37, 0xef, 0xdb, 0xdf, 0xff, 0xff, 0xf0, 0x7f, 0xf8, 0x3f,
  0xff, 0xf8, 0x7d, 0xdf, 0x0e, 0xf8, 0xb7, 0xec, 0x3b, 0xdf, 0xff, 0xff, 0xf8, 0x7f, 0xfc, 0x7f,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xfc, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};


void setup() {
  
  Serial.begin(115200);
  EEPROM.begin(sizeof(Config));                       //инициализация EEPROM памяти в размере = размеру структуры Config
  Serial.println("Инициализированно " + String(sizeof(Config)) + " byte EEPROM памяти");
  
  pinMode (2, OUTPUT); //D4
  pinMode (14, INPUT); //D5
  digitalWrite(2, HIGH);

  display.setTextSize(2);
  display.setTextColor(WHITE);
  display.setCursor(0, 0);


  Serial.begin(115200);
  // initialize with the I2C addr 0x3C
  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);
  display.clearDisplay();
  display.drawBitmap(0, 0, logo, 128, 32, WHITE);
  display.display();


  Read_Config();
  
  WiFi_init();
  display_ip();
  Init_html();
  OTA_Update();

}

void loop() {

  server.handleClient();
  ArduinoOTA.handle();

  button = digitalRead(14);

  if (button < 1 )
  {
    digitalWrite(2, LOW);
    count++;
    delay(10);
    digitalWrite(2, HIGH);

  }

  if (millis() - premillis_disp > set_time_change_display * 1000) //циклический вывод на экран информации каждые Х секунды
  {
    premillis_disp = millis();
    display_out();
    display_number = !display_number;
  }


  if (millis() - premillis > set_time_expo)
  {
    premillis = millis();
    temp = count * (1.0/Config.EXPOSITION);
    SendToNM();
    count = 0;
  }

}
